extern task memcpy(dest: &any, src: &any, n: u64);
extern task printf(...);
extern task putchar(c: u32);
@cfg_platform("nt", "extern task Sleep(time: u32);");
@cfg_platform("posix", "extern task usleep(time: u32);");

@cfg_platform("nt", "task tbl_sleep(time: u32) {Sleep(time); return;}");
@cfg_platform("posix", "task tbl_sleep(time: u32) {usleep(time * 1000); return;}");

struct Task {
    task_: task(&any) -> &any,
    args: &any,
    running: bool
}

struct Scheduler {
    tasks: [Task; 64],
    num_tasks: i64,
    current: i64
}

global SCHED: Scheduler = {tasks: [], num_tasks: 0, current: -1};
global TASK_EXITED: bool = false;

task sched_enqueue(task_: task(&any) -> &any, args: &any, arg_size: u64) {
    ((SCHED.tasks)[SCHED.num_tasks]).task_ = task_; //= {task_: task_, args: 0, running: true};
    memcpy(&(((SCHED.tasks)[SCHED.num_tasks]).args), args, arg_size);
    ((SCHED.tasks)[SCHED.num_tasks]).running = true;
    SCHED.num_tasks = SCHED.num_tasks + 1;
    if (SCHED.current == -1) {
        SCHED.current = 0;
    }
}

task sched_exit() {
    TASK_EXITED = true;
}

task sched_run() 
<current: i64, t: Task, t1: task(&any) -> &any, args: &any>
{
   current = SCHED.current;
   if (current == -1) {
    return;
   }
   t = (SCHED.tasks)[current];
   //printf("%d\n", t.running);
   if t.running == true {
        t1 = t.task_;
        args = t.args;
        t1(args);
        if TASK_EXITED {
         ((SCHED.tasks)[current]).running = false;
         TASK_EXITED = false;
        }
   }
   SCHED.current = SCHED.current + 1;
   if (SCHED.current == SCHED.num_tasks) {
        SCHED.current = 0;
   }
   tbl_sleep(100);
   sched_run();
   return;
}